## toi16_carte
[problem statement](https://programming.in.th/tasks/toi16_carte)

<details>
  <summary>hints</summary>
  <ul>
    <details>
      <summary>hint 1</summary>
      <p>ลองมองเป็นช่วงๆ แล้วดูว่าเราสามารถเอาคำตอบของช่วงเล็กๆไปช่วยตอบช่วยใหญ่ๆได้ไหม</p>
    </details>
    <details>
      <summary>hint 2</summary>
      <p>ลองคิดดูแบบสามารถดึงได้ทีละกี่อันก็ได้ก่อน (ไม่มีจำกัดดึงทีละ k ครั้ง)</p>
    </details>
    <details>
      <summary>hint 3</summary>
      <p>พอมีข้อจำกัดดึงได้ทีละ k ครั้งเราก็แค่เช็คว่าสำหรับช่วงช่วงนี้เราดึงไปแล้วกี่ครั้ง</p>
    </details>
  </ul>
</details>

<details>
  <summary>prerequisites</summary>
  <p><ins>dp</ins>, range dp</p>
</details>

<details>
  <summary>solution</summary>
  <ul>
    <li>เพื่อความง่าย เราจะพิจารณาโจทย์ในรูปแบบที่ไม่มีความจุของกระทะ K ก่อน </li>
    <li>เราอาจลองคิดแบบ greedy หยิบช่วงที่ติดกันยาวที่สุดก่อน แต่เมื่อพิจารณาบางตัวอย่าง เช่น <code>1 1 1 1 1 2 1 1 1 1</code> ก็จะเห็นได้ชัดว่าควรหยิบ <code>2</code> ที่มีเพียงตัวเดียวก่อนเพื่อเชื่อม <code>1</code> ด้านซ้ายและขวาเข้าด้วยกัน เนื่องจากเรารู้ว่ามีคำตอบที่ถูกต้องอยู่แล้ว เราก็สามารถมองหา property บางอย่างของคำตอบได้ เช่น คำตอบมาจากลำดับการหยิบที่ดีที่สุด </li>
    <li>ดังนั้นเราอาจลอง brute force การหยิบทุกช่วงที่เป็นไปได้แล้วพิจารณาช่วงที่เหลือจากการหยิบ แต่เนื่องจากวิธีนี้ใช้เวลาเกินอย่างแน่นอน และการ simulate การหยิบแล้วให้ช่วงด้านซ้ายกับขวามาเชื่อมกันทำได้ยาก เราจึงมองเป็นการแบ่งช่วงใหญ่ออกเป็นช่วงเล็ก ๆ แทน แล้วค่อยรวมคำตอบของแต่ละช่วงที่แบ่งไป</li>
    <li>เมื่อเรามองปัญหาเป็นการหาคำตอบของแต่ละช่วงจากการแบ่งช่วงได้ เราก็จะเริ่มมองปัญหาขนาดเล็ก ถ้าช่วงมีขนาดเป็น 1 เราสามารถหยิบได้ในครั้งเดียว ถ้ามีขนาดเป็น 2 เราอาจหยิบได้ในหนึ่งครั้งหากใบด้านซ้ายกับด้านขวาเหมือนกัน หรือสองครั้งหากต่างกัน (<code>1 1</code> → 1 ครั้ง, <code>1 2</code> → 2 ครั้ง)  จุดสังเกตคือหากใบซ้ายสุดกับขวาสุดของช่วงใด ๆ เหมือนกัน เราสามารถหยิบสองใบนั้นพร้อมกันได้ </li>
    <li>เมื่อได้อย่างนี้แล้ว สำหรับคำตอบของช่วง $[i,j]$ ใด ๆ เราก็เพียงทดลอง partition ที่ทุก ๆ จุด k ที่ $i \leq k < j$ แล้วนำคำตอบของช่วง $[i,k]$ กับ $[k+1,j]$ มารวมกัน โดยหากตัวซ้ายสุดและขวาสุดเหมือนกันเราสามารถ -1 คำตอบได้</li>
    <li>ได้ subproblem เป็น<br>
    <code>dp[i][j]</code> = จำนวนครั้งในการดึงออกที่น้อยที่สุดของช่วง i ถึง j<br> 
    base case คือ <br>
    <code>dp[i][i] = 1</code> เพราะถ้ามีใบเดียว อย่างไรก็สามารถหยิบได้วิธีเดียว<br>
    และ recurrence relation <br>
    <code>dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]) - (arr[i]==arr[j])</code>
    </li>
    <li>และทำการลูปตั้งแต่ขนาดช่วงเป็น 1 ถึง N ไปเรื่อย ๆ แล้วเช็คการ partition ทุกจุดในช่วง ได้เป็น time complexity : $$O(N^3)$$</li>
    <li>จากนั้นเราจะสามารถพิจารณาค่า K ได้โดยการเก็บจำนวนใบที่ติดกันที่หยิบไปแล้วสำหรับแต่ละช่วง ถ้าหยิบเกินก็จะไม่สามารถ -1 ได้</li>
    <li>bonus : โจทย์ที่คล้ายเคียง <a href="https://leetcode.com/problems/strange-printer/description/">https://leetcode.com/problems/strange-printer/description/</a></li>
</ul>
</details>

[ac code](./toi16_carte.cpp)
